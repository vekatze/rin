import {
  binary-builder.entity {builder, create, get},
  binary-builder.scene {_get-head-ptr, _proceed},
  core.external {free},
  core.memory {load-int},
  core.text {_Text, _from-c-string, text-byte-length},
  core.word,
  http-base.field {Field},
  http-base.header {header},
  http-base.request {Request, request},
  http-base.request-method.show {show-request-method},
  http-base.response {Response, response},
  path.path,
  this.context.foreign {
    CURLH_HEADER,
    CURLINFO_RESPONSE_CODE,
    CURLOPT_CUSTOMREQUEST,
    CURLOPT_FOLLOWLOCATION,
    CURLOPT_HTTPHEADER,
    CURLOPT_POSTFIELDS,
    CURLOPT_POSTFIELDSIZE,
    CURLOPT_URL,
    CURLOPT_WRITEDATA,
    CURLOPT_WRITEFUNCTION,
  },
  this.context.rin {rin},
  this.entity.config {Config, config},
  this.entity.handle {
    _curl_easy_getinfo,
    _curl_easy_perform,
    _curl_easy_setopt,
    _curl_easy_setopt_bool,
    _curl_easy_setopt_text,
    _with-handle,
    handle,
  },
  this.entity.slist {_slist, _with-header},
}

foreign {
  llvm.memcpy.p0.p0.i64(pointer, pointer, int64, int1): void,
  curl_easy_nextheader(pointer, int, int, pointer): pointer,
  neut_rin_v0_1_get_header_name(pointer): pointer,
  neut_rin_v0_1_get_header_value(pointer): pointer,
}

define _callback(ptr: int, size: int, nmemb: int, stream: &builder): int {
  let total-size = mul-int(size, nmemb) in
  let content-head-ptr = _get-head-ptr(stream, total-size) in
  let zero: int = 0 in
  magic external llvm.memcpy.p0.p0.i64(content-head-ptr, ptr, total-size, zero);
  _proceed(stream, total-size);
  total-size
}

define _get-callback-label-ptr(): int {
  let callback-ptr = magic cast(_, int, _callback) in
  let callback-label-ptr = load-int(add-int(callback-ptr, mul-int(core.word.size, 2))) in
  free(callback-ptr);
  callback-label-ptr
}

define _read-all-headers(h: handle, cursor: int): header {
  let last: int = -1 in
  let new-header = magic external curl_easy_nextheader(h, CURLH_HEADER, last, cursor) in
  if eq-int(new-header, 0) {
    []
  } else {
    let name = _from-c-string(magic external neut_rin_v0_1_get_header_name(new-header)) in
    let value = _from-c-string(magic external neut_rin_v0_1_get_header_value(new-header)) in
    Cons(Field(name, value), _read-all-headers(h, new-header))
  }
}

define perform(req: request, c: config): rin(response) {
  _with-handle(function (h) {
    let Config of {host, buffer-size, follow-location} = c in
    try _ = _curl_easy_setopt_bool(h, CURLOPT_FOLLOWLOCATION, follow-location) in
    let Request of {method, path, fields, body} = req in
    let url on path = path.path.append(host, path) in
    pin url = url in
    try _ = _curl_easy_setopt_text(h, CURLOPT_URL, url) in
    // set method
    pin method' = show-request-method(method) in
    try _ = _curl_easy_setopt_text(h, CURLOPT_CUSTOMREQUEST, method') in
    _with-header(fields, function (slist) {
      try _ = _curl_easy_setopt(h, CURLOPT_HTTPHEADER, magic cast(_slist, int, slist)) in
      pin body = body in
      try _ = _curl_easy_setopt_text(h, CURLOPT_POSTFIELDS, body) in
      try _ = _curl_easy_setopt(h, CURLOPT_POSTFIELDSIZE, text-byte-length(body)) in
      // get the closure ptr
      let callback-label-ptr = _get-callback-label-ptr() in
      // set the response reader
      let body-buffer = create(buffer-size) in
      let _ on body-buffer = _curl_easy_setopt(h, CURLOPT_WRITEDATA, magic cast(&builder, int, body-buffer)) in
      try _ = _curl_easy_setopt(h, CURLOPT_WRITEFUNCTION, callback-label-ptr) in
      // perform request
      try _ = _curl_easy_perform(h) in
      try status-code = _curl_easy_getinfo(h, CURLINFO_RESPONSE_CODE) in
      let fields = _read-all-headers(h, 0) in
      let body = _Text(get(body-buffer)) in
      Right(
        Response of {
          status-code,
          fields,
          body,
        },
      )
    })
  })
}
